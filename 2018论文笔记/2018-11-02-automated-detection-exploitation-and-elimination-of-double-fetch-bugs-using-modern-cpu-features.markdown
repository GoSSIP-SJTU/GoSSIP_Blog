---
layout: post
title: "Automated Detection Exploitation and Elimination of Double-Fetch Bugs using Modern CPU Features"
date: 2018-11-02 19:51:45 +0800
comments: true
categories: 
---

作者: Michael Schwarz, Daniel Gruss, Moritz Lipp, Clémentine Maurice, Thomas Schuster, Anders Fogh, Stefan Mangard

单位: Graz University of Technology, CNRS, G DATA Advanced Analytic

出处: AsiaCCS'18

原文: https://dl.acm.org/citation.cfm?id=3196508

Double-fetch bugs 是一种特殊的条件竞争，在高权限线程的time-of-check和time-of-use之间，低权限线程能够修改共享的内存，导致高权限线程访问的内存产生不一致。

本文作者提出了一种检测，利用并消除double-fetch bugs的技术DECAF和Dropit。总体来说，贡献如下：

*   把cache attack与kernel fuzzing结合起来
*   首个自动化的挖掘double-fetch bugs的方法
*   利用的成功率高达97%
*   利用Hardware Transactional Memory的特性，消除double-fetch bugs
*   方法对fuzz TEE也有效

<!--more-->

## 介绍
现代操作系统的安全依赖操作系统kernel提供隔离性，在对kernel的攻击中，条件竞争是一个很难解决的问题。Double-fetch bugs 就是一种特殊的条件竞争。kernel两次访问同一块内存，首先检查数据的合法性，第二次就使用它，那在这两者之间，内存可能被修改。
Double Fetches有个明显的特征是要访问两次内存。如果数据在cache中，就从cache中读，如果不在就从主存中读到cache中，基于cache的攻击，比如著名的Flush+Reload攻击，可以利用CPU的这个特性来检测Double Fetches。

Intel TSX的hardware transactional memory特性能够保证当数据被读进transaction后，数据不能被任何transaction之外的操作修改。这种特性被用来实现安全加固，比如在这个场景中就可以天然的防御Double Fetch bugs。

## 组成
![](/images/2018-11-02/media/15284272421980/15284300515705.jpg)

* 通过Flush+Reload边信道检测double fetches
* 判断double fetches是否能够被利用
* 通过hardware transactional memory消除double fetch bugs

## 检测
主要思想是监控cache访问syscall的参数（比如指针，结构体中的指针），筛选出这些指针后，另起一个Flush+Reload线程对这些指针进行监控。

效果如下所示，可以明显的看到两次cache的访问。
![](/images/2018-11-02/media/15284272421980/15284306145290.jpg)

### 多次cache hit的分类

影响cache acess pattern的因素

*   size of data type
*   parameter reuse

### 检测的概率
检测成功的概率取决于两次访问时间的间隔。因为本身Flush+Reload需要把数据从cache中清掉，这要消耗大概200多个CPU周期，这就要保证double fetch的两次访问间隔至少要是Flush+Reload两倍的的时间才行。
![](/images/2018-11-02/media/15284272421980/15284314884284.jpg)

### TrinityDECAF
作者基于trinity这个kernel syscall fuzz框架，实现了 TrinityDECAF，架构如图，基于trinity，为每个syscall的参数实现了一个监控的进程。
![](/images/2018-11-02/media/15284272421980/15284316070280.jpg)

## 利用
Flush-Reload or Flush+Flush

fuzz策略

*   参数值改成0
*   翻转最低有效比特
*   增加值
*   参数值改为随机值

## 消除
作者实现了Dropit的库，这个是基于硬件的特性，hardware transactional memory保证了两次内存访问之间不能再对该内存修改。实现起来也很简单，使用Intel TSX的XBEGIN和XEND指令讲存在bug的代码包起来即可。

![](/images/2018-11-02/media/15284272421980/15284372760427.jpg)

## 评估
### DECAF
已知漏洞CVE-2016-6516
![](/images/2018-11-02/media/15284272421980/15284408717916.jpg)
可行性
![](/images/2018-11-02/media/15284272421980/15284408966196.jpg)
有效性
![](/images/2018-11-02/media/15284272421980/15284412241386.jpg)
利用的成功率
![](/images/2018-11-02/media/15284272421980/15284412658863.jpg)
在TEE上fuzz
![](/images/2018-11-02/media/15284272421980/15284413132778.jpg)
使用dropit和不使用的比较
![](/images/2018-11-02/media/15284272421980/15284414089616.jpg)
